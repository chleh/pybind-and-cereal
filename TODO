
[x] const members (maybe not, because not supported by python)
[ ] Python bindings for STL containers
    [v] --> name mangling
[v] steal from custom shared_ptr
    * go back to custom unique_ptr, provide item copier/mover there
      * implemented copier/mover in custom shared_ptr
    * maybe it's comparably reasonable to keep moving pointers around
      * no it's not. Better: copy/move in, then get new reference to C++ object
        back, because this ties the lifetime of the owner to the lifetime of the
        returned reference. This is now implemented.
[ ] overridden methods (write test)
[ ] static methods
[v] check is_default_constructible
[ ] guess some constructors, e.g. a constructor taking all the direct data members in
    the order defined by the reflection
[ ] custom ctors
[v] copy constructor, but not move ctor (because not supported by python)
[ ] split tests
[ ] derived class member shadowing base class member
[v] http://www.boost.org/doc/libs/master/libs/core/doc/html/core/demangle.html
[ ] multiple inheritance
[ ] refactoring:
    [ ] namespaces
    [ ] split tests
    [ ] more tests (pybind and serialization)
    [ ] rename macros
    [ ] more static assertions, e.g. is_base_of, no pointer types supported
    [ ] smart_ptr<T> --> std::shared_ptr<Item<T>>
    [ ] clean up includes
[v] function overloads (e.g., for assigning nullptr to unique_ptr)
[ ] submodules
[ ] test inheritance in python
[ ] compilation speed
[ ] check return policy for pointers, l-value refs, rvalues
    [v] getters (def_read...()) are return_value_policy::reference_internal (pybind11.h)
    *   default return value policy is automatic (check struct function_record),
        i.e., copy/move for l-/r-values
    [v] data members of type unique_ptr
    [v] return values of member functions
    [ ] write tests for that
[ ] overloaded methods (don't fit the current macros), check py::overload_cast


Non-Features
============

* enums
* templated member functions
* pointer data members: conflicts with cereal

