
[x] const members (maybe not, because not supported by python)
[ ] Python bindings for STL containers
    [v] --> name mangling
[v] steal from custom shared_ptr
    * go back to custom unique_ptr, provide item copier/mover there
      * implemented copier/mover in custom shared_ptr
    * maybe it's comparably reasonable to keep moving pointers around
      * no it's not. Better: copy/move in, then get new reference to C++ object
        back, because this ties the lifetime of the owner to the lifetime of the
        returned reference. This is now implemented.
[ ] overridden methods (write test)
[ ] static methods
[v] check is_default_constructible
[ ] guess some constructors, e.g. a constructor taking all the direct data members in
    the order defined by the reflection
[/] custom ctors
[v] copy constructor, but not move ctor (because not supported by python)
[v] split tests
[ ] derived class member shadowing base class member
[v] http://www.boost.org/doc/libs/master/libs/core/doc/html/core/demangle.html
[ ] multiple inheritance
[ ] refactoring:
    [ ] namespaces
    [v] split tests
    [ ] more tests (pybind and serialization)
    [ ] rename macros
    [ ] more static assertions, e.g. is_base_of, no pointer types supported
    [v] smart_ptr<T> --> std::shared_ptr<Item<T>>
        [/] write smart_ptr tests
    [ ] clean up includes
[v] function overloads (e.g., for assigning nullptr to unique_ptr)
[ ] python submodules
[ ] test inheritance in python
[ ] compilation speed
[ ] check return policy for pointers, l-value refs, rvalues
    [v] getters (def_read...()) are return_value_policy::reference_internal (pybind11.h)
    *   default return value policy is automatic (check struct function_record),
        i.e., copy/move for l-/r-values
    [v] data members of type unique_ptr
    [v] return values of member functions
    [ ] write tests for that
[ ] overloaded methods (don't fit the current macros), check py::overload_cast
    maybe add REFLECT_FULL(...) macro
[ ] functions with unique_ptr returns/args
[ ] test std::vector<std::unique_ptr<T>>
[v] "Unable to load a custom holder type from a default-holder instance"
    e.g., with std::vector<int>
    [x] maybe circumvent by globally setting the pybind11 holder type
        --> default is unique_ptr, cf. pybind11.h
    [x] maybe circumvent by wrapping std::vector<int> in some custom type
    * issue resolved by specifying right holder type for std::vector

[ ] check https://github.com/RosettaCommons/binder


Non-Features
============

* enums
* templated member functions
* pointer data members: conflicts with cereal

